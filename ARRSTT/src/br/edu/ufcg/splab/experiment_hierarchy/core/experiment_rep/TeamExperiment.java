package br.edu.ufcg.splab.experiment_hierarchy.core.experiment_rep;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import br.edu.ufcg.splab.experiment_hierarchy.core.combinators.ExperimentSetUpSearches;
import br.edu.ufcg.splab.experiment_hierarchy.core.treatments.ExecutableTreatment;
import br.edu.ufcg.splab.experiment_hierarchy.core.treatments.TreatmentSearch;
import br.edu.ufcg.splab.experiment_hierarchy.searches.BreadthFirstSearch;
import br.edu.ufcg.splab.experiment_hierarchy.searches.DepthFirstSearch;
import br.edu.ufcg.splab.experiment_hierarchy.searches.InterfaceSearch;
import br.edu.ufcg.splab.experiment_hierarchy.util.BranchSeparator;
import br.edu.ufcg.splab.experiment_hierarchy.util.ExperimentFile;
import br.edu.ufcg.splab.experiment_hierarchy.util.Tuple;
import br.edu.ufcg.splab.experiment_hierarchy.util.testcollections.TestSuite;
import br.edu.ufcg.splab.graph.core.InterfaceGraph;

/**
 * This is the class that should execute the specific experiment made
 * on the ARRSTT project. 
 */
public class TeamExperiment {
	public static final String LINE_END = System.getProperty("line.separator");
	
	/**
	 * This object is used to produce a list of graphs
	 * with the same amount of low on branch graphs and
	 * high on branch graphs.
	 */
	private BranchSeparator separator;
	/**
	 * The list of graphs to be evaluated by the experiment.
	 * This list is filled with the output of the separator.
	 */
	private List<InterfaceGraph> graphs;
	/**
	 * The loop coverages in which the searches will run.
	 */
	private int[] loopCoverages;
	/**
	 * Represents a file containing the size of all the
	 * test suites generated by the searches during the 
	 * execution of the experiment.
	 */
	private ExperimentFile tsSizeFile;
	/**
	 * Represents a file containing times in which
	 * search calls took to return a testSuite.
	 */
	private ExperimentFile timeFile;
	
	private ExperimentSetUpSearches setter;
	
	/**
	 * Build a new TeamExperiment passing all the loop coverages.
	 * 
	 * @param loopCoverages
	 * 		The loop coverages in which the searches will run.
	 * @throws Exception
	 */
	public TeamExperiment(int[] loopCoverages) throws Exception {
		this.separator = new BranchSeparator();
		this.tsSizeFile = new ExperimentFile("Sizes");
		this.timeFile = new ExperimentFile("Times");
		this.graphs = separator.getGraphsToRun();		
		this.loopCoverages = loopCoverages;
		this.setter = new ExperimentSetUpSearches(graphs, loopCoverages);
	}

	/**
	 * This method takes care of generating all the output data of this
	 * particular experiment.
	 * 
	 * @throws Exception
	 */
	public void runExperiment() throws Exception {
		List<Tuple<ExecutableTreatment>> combinations = setter.combine();
		
		int count = 0;
		for(Tuple<ExecutableTreatment> combination : combinations) {
			for (ExecutableTreatment treatment: combination) {
				Long initTime = System.nanoTime();
				TestSuite testSuite = treatment.execute();
				Long endTime = System.nanoTime();
			
				Long timeDif = (endTime - initTime);
			
				timeFile.appendContent(timeDif + "\t");
				tsSizeFile.appendContent(testSuite.size() + "\t");
			
				// Probably will go to formatter later.
				count += 1;
				if(count == 6) {
					timeFile.appendContent(LINE_END);
					tsSizeFile.appendContent(LINE_END);
					count = 0;
				}	
			}
		}
		
		saveFiles();
	}
	
	private void saveFiles() throws IOException {
		timeFile.save();
		tsSizeFile.save();
	}
	
	/**
	 * This method do what the combinator is supposed to do.
	 * That is, for each graph it will vary the searches and
	 * loop coverages, generating the combinations that will 
	 * be executed by the runExperiment method.
	 * 
	 * @return
	 * 		A list containing the combinations.
	 */
	private List<ExecutableTreatment> combine() {
		// this method will probably become useless later.
		List<ExecutableTreatment> combinations = new ArrayList<ExecutableTreatment>();
		List<InterfaceSearch> searches = new ArrayList<InterfaceSearch>();
		searches.add(new DepthFirstSearch());
		searches.add(new BreadthFirstSearch());
		
		for(InterfaceGraph graph : graphs) {
			for(InterfaceSearch search: searches) {
				for(Integer loopCoverage : loopCoverages) {
					combinations.add(new TreatmentSearch(search, graph.getRoot(), loopCoverage, ""));
				}
			}
		}
		
		return combinations;
	}
}
